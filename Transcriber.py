import subprocess
import assemblyai as aai
import os
import sys
import time
import glob
import configparser
from datetime import timedelta

# Version info
VERSION = "1.1"
APP_NAME = "Video Transcriber"


def get_application_path():
    """Get the directory where the application is running from"""
    if getattr(sys, 'frozen', False):
        return os.path.dirname(sys.executable)
    else:
        return os.path.dirname(__file__)


def setup_api_key():
    """Setup API key from config file or user input"""
    config_file = os.path.join(get_application_path(), "config.ini")
    config = configparser.ConfigParser()

    if os.path.exists(config_file):
        config.read(config_file)
        api_key = config.get('API', 'assemblyai_key', fallback='')
    else:
        api_key = ''

    if not api_key:
        print("\n" + "=" * 50)
        print("AssemblyAI API Key Setup")
        print("=" * 50)
        print("To use this transcriber, you need a free API key from AssemblyAI.")
        print("1. Go to: https://www.assemblyai.com/")
        print("2. Sign up for a free account")
        print("3. Copy your API key")
        print("=" * 50)

        while True:
            api_key = input("Enter your AssemblyAI API key: ").strip()
            if api_key:
                break
            print("API key cannot be empty. Please try again.")

        # Save for future use
        if not config.has_section('API'):
            config.add_section('API')
        config.set('API', 'assemblyai_key', api_key)

        try:
            with open(config_file, 'w') as f:
                config.write(f)
            print("\n✓ API key saved for future use.")
        except:
            print("\n⚠ Could not save API key. You'll need to enter it again next time.")

    return api_key

def prompt_for_new_api_key():
    print("\nYour current AssemblyAI API key is invalid or has reached its usage/quota limit.")
    print("Please create a new API key in your AssemblyAI dashboard and enter it below.")
    print("Dashboard: https://app.assemblyai.com/")
    while True:
        new_key = input("Enter new AssemblyAI API key: ").strip()
        if new_key:
            break
        print("API key cannot be empty. Please try again.")
    # Optionally update config file
    config_file = os.path.join(get_application_path(), "config.ini")
    config = configparser.ConfigParser()
    if os.path.exists(config_file):
        config.read(config_file)
    if not config.has_section('API'):
        config.add_section('API')
    config.set('API', 'assemblyai_key', new_key)
    with open(config_file, 'w') as f:
        config.write(f)
    return new_key


def combine_transcripts(folder_path, output_folder):
    """Combine English and German transcript files into separate combined files"""
    print("\n" + "=" * 50)
    print("Combining Transcript Files")
    print("=" * 50)

    # Find all English and German transcript files
    english_files = glob.glob(os.path.join(folder_path, '*_transcript_EN.txt'))
    german_files = glob.glob(os.path.join(folder_path, '*_transcript_DE.txt'))

    print(f"Found {len(english_files)} English transcript(s)")
    print(f"Found {len(german_files)} German transcript(s)")

    # Define output combined file paths
    combined_english_path = os.path.join(output_folder, 'Combined_English_Transcripts.txt')
    combined_german_path = os.path.join(output_folder, 'Combined_German_Transcripts.txt')

    # Combine English transcripts
    if english_files:
        with open(combined_english_path, 'w', encoding='utf-8') as outfile:
            outfile.write("COMBINED ENGLISH TRANSCRIPTS\n")
            outfile.write(f"Generated by {APP_NAME} v{VERSION}\n")
            outfile.write(f"Combined Date: {time.strftime('%Y-%m-%d %H:%M:%S')}\n")
            outfile.write(f"Total Files: {len(english_files)}\n")
            outfile.write("=" * 80 + "\n\n")

            for i, fname in enumerate(english_files, 1):
                with open(fname, 'r', encoding='utf-8') as infile:
                    outfile.write(f"\n{'-' * 60}\n")
                    outfile.write(f"FILE {i}/{len(english_files)}: {os.path.basename(fname)}\n")
                    outfile.write(f"{'-' * 60}\n")
                    outfile.write(infile.read())
                    outfile.write(f"\n{'-' * 60}\n")
                    outfile.write(f"END OF FILE {i}: {os.path.basename(fname)}\n")
                    outfile.write(f"{'-' * 60}\n\n")

        print(f"✓ Combined English transcripts saved to: {combined_english_path}")
    else:
        print("No English transcripts found to combine.")

    # Combine German transcripts
    if german_files:
        with open(combined_german_path, 'w', encoding='utf-8') as outfile:
            outfile.write("KOMBINIERTE DEUTSCHE TRANSKRIPTE\n")
            outfile.write(f"Erstellt von {APP_NAME} v{VERSION}\n")
            outfile.write(f"Kombiniert am: {time.strftime('%Y-%m-%d %H:%M:%S')}\n")
            outfile.write(f"Anzahl Dateien: {len(german_files)}\n")
            outfile.write("=" * 80 + "\n\n")

            for i, fname in enumerate(german_files, 1):
                with open(fname, 'r', encoding='utf-8') as infile:
                    outfile.write(f"\n{'-' * 60}\n")
                    outfile.write(f"DATEI {i}/{len(german_files)}: {os.path.basename(fname)}\n")
                    outfile.write(f"{'-' * 60}\n")
                    outfile.write(infile.read())
                    outfile.write(f"\n{'-' * 60}\n")
                    outfile.write(f"ENDE DER DATEI {i}: {os.path.basename(fname)}\n")
                    outfile.write(f"{'-' * 60}\n\n")

        print(f"✓ Combined German transcripts saved to: {combined_german_path}")
    else:
        print("Keine deutschen Transkripte zum Kombinieren gefunden.")

    return combined_english_path if english_files else None, combined_german_path if german_files else None


def get_user_folders():
    """Get folder paths from user input"""
    print("\n" + "=" * 50)
    print("Folder Setup")
    print("=" * 50)

    # Get video folder
    while True:
        print("\nStep 1: Video Source Folder")
        folder_path = input("Enter the full path to your video folder: ").strip('"\'')

        if os.path.exists(folder_path):
            video_files = get_video_files(folder_path)
            if video_files:
                print(f"✓ Found {len(video_files)} video file(s) in this folder.")
                break
            else:
                print("⚠ No video files found in this folder. Please try another folder.")
        else:
            print("⚠ Folder not found. Please check the path and try again.")

    # Get output folder
    while True:
        print("\nStep 2: Transcript Output Folder")
        output_folder = input("Enter the path where transcripts should be saved: ").strip('"\'')

        try:
            os.makedirs(output_folder, exist_ok=True)
            print(f"✓ Output folder ready: {output_folder}")
            break
        except Exception as e:
            print(f"⚠ Cannot create output folder: {e}")
            print("Please try a different path.")

    return folder_path, output_folder


def yes_or_no_prompt(question, default_yes=True):
    """Prompt user for yes/no answer"""
    default = 'y' if default_yes else 'n'
    prompt_choice = "(Y/n)" if default_yes else "(y/N)"

    while True:
        try:
            reply = input(f"{question} {prompt_choice}: ").lower().strip()
            reply = reply or default

            if reply in ['y', 'yes']:
                return True
            elif reply in ['n', 'no']:
                return False
            else:
                print("Please respond with 'yes' or 'no' (or 'y' or 'n').")
        except (ValueError, KeyboardInterrupt):
            print("\nOperation cancelled by user.")
            return False


def get_speaker_names_by_language(language_code):
    """Return appropriate speaker names based on detected language"""
    language_configs = {
        'de': {"A": "Sprecher_A", "B": "Sprecher_B"},
        'en': {"A": "Speaker_A", "B": "Speaker_B"},
    }
    return language_configs.get(language_code, {"A": "Speaker_A", "B": "Speaker_B"})


def get_video_files(folder_path):
    """Get all video files from the specified folder"""
    video_extensions = ['*.mp4', '*.mkv', '*.avi', '*.mov', '*.flv', '*.wmv', '*.webm', '*.m4v']
    video_files = []

    for extension in video_extensions:
        pattern = os.path.join(folder_path, extension)
        video_files.extend(glob.glob(pattern))
        # Also check subdirectories
        pattern = os.path.join(folder_path, "**", extension)
        video_files.extend(glob.glob(pattern, recursive=True))

    return sorted(list(set(video_files)))


def format_timestamp(milliseconds):
    """Convert milliseconds to HH:MM:SS format"""
    return str(timedelta(seconds=int(milliseconds / 1000)))


def check_ffmpeg():
    """Check if ffmpeg is available"""
    try:
        app_path = get_application_path()
        local_ffmpeg = os.path.join(app_path, "ffmpeg.exe")

        if os.path.exists(local_ffmpeg):
            return local_ffmpeg

        subprocess.run(["ffmpeg", "-version"], capture_output=True, check=True)
        return "ffmpeg"
    except:
        return None


def transcribe_single_video(video_path, output_folder, keep_audio_files, ffmpeg_path):
    """Transcribe a single video file with automatic language detection"""
    print(f"\n{'=' * 60}")
    print(f"Processing: {os.path.basename(video_path)}")
    print(f"{'=' * 60}")

    video_name = os.path.splitext(os.path.basename(video_path))[0]
    audio_path = os.path.join(output_folder, f"{video_name}_audio.wav")

    try:
        # Step 1: Extract audio
        print("Step 1: Extracting audio from video...")
        audio_start = time.time()
        ffmpeg_cmd = [
            ffmpeg_path, "-y", "-i", video_path,
            "-ab", "160k", "-ac", "1", "-ar", "16000", "-vn", audio_path
        ]

        result = subprocess.run(ffmpeg_cmd, capture_output=True, text=True)
        if result.returncode != 0:
            raise Exception(f"FFmpeg error: {result.stderr}")

        audio_end = time.time()
        print(f"✓ Audio extraction completed in {audio_end - audio_start:.2f} seconds")

        # Step 2: Configure transcription
        config = aai.TranscriptionConfig(
            language_detection=True,
            language_confidence_threshold=0.3,
            speech_model=aai.SpeechModel.best,
            speaker_labels=True,
            speakers_expected=2
        )

        # Step 3: Transcribe audio
        print("Step 2: Starting transcription with automatic language detection...")
        transcription_start = time.time()
        transcriber = aai.Transcriber()
        transcript = transcriber.transcribe(audio_path, config)
        transcription_end = time.time()

        if transcript.status == "error":
            raise RuntimeError(f"Transcription failed: {transcript.error}")

        # Get detected language information
        detected_language = transcript.json_response.get("language_code", "unknown")
        language_confidence = transcript.json_response.get("language_confidence", 0.0)

        print(f"✓ Transcription completed in {transcription_end - transcription_start:.2f} seconds")
        print(f"✓ Detected Language: {detected_language.upper()} (Confidence: {language_confidence:.3f})")

        # Get appropriate speaker names
        speaker_names = get_speaker_names_by_language(detected_language)

        # Generate transcript filename with language suffix
        language_suffix = detected_language.upper() if detected_language != "unknown" else "AUTO"
        transcript_path = os.path.join(output_folder, f"{video_name}_transcript_{language_suffix}.txt")

        # Step 4: Format and save transcript
        print("Step 3: Formatting and saving transcript...")
        format_start = time.time()

        language_headers = {
            'de': {
                'title': 'INTERVIEW TRANSKRIPT',
                'language_label': 'Sprache: Deutsch',
                'confidence_label': 'Vertrauen'
            },
            'en': {
                'title': 'INTERVIEW TRANSCRIPT',
                'language_label': 'Language: English',
                'confidence_label': 'Confidence'
            }
        }

        headers = language_headers.get(detected_language, language_headers['en'])

        with open(transcript_path, "w", encoding="utf-8") as f:
            f.write(f"{headers['title']} - {video_name}\n")
            f.write(f"Generated by {APP_NAME} v{VERSION}\n")
            f.write(f"{headers['language_label']}\n")
            f.write(f"{headers['confidence_label']}: {language_confidence:.3f}\n")
            f.write(f"Processing Date: {time.strftime('%Y-%m-%d %H:%M:%S')}\n")
            f.write("=" * 60 + "\n\n")

            for utterance in transcript.utterances:
                timestamp = format_timestamp(utterance.start)
                speaker_name = speaker_names.get(utterance.speaker, f"Speaker_{utterance.speaker}")
                text = utterance.text

                f.write(f"[{timestamp}] {speaker_name}: {text}\n\n")

        format_end = time.time()
        print(f"✓ Formatting completed in {format_end - format_start:.2f} seconds")
        print(f"✓ Transcript saved to: {transcript_path}")

        # Handle audio file cleanup
        if not keep_audio_files and os.path.exists(audio_path):
            os.remove(audio_path)
            print("✓ Temporary audio file deleted")
        elif keep_audio_files:
            print(f"✓ Audio file saved to: {audio_path}")

        return True, detected_language

    except Exception as e:
        print(f"✗ Error processing {video_name}: {str(e)}")
        if os.path.exists(audio_path):
            try:
                os.remove(audio_path)
            except:
                pass
        return False, "unknown"


def main():
    """Main function for the standalone application"""
    print(f"\n{APP_NAME} v{VERSION}")
    print("=" * 60)
    print("Batch Video Transcription with Automatic Language Detection")
    print("and Automatic Transcript Combining")
    print("=" * 60)

    try:
        # Step 1: Setup API key
        api_key = setup_api_key()
        aai.settings.api_key = api_key

        # Step 2: Check ffmpeg
        ffmpeg_path = check_ffmpeg()
        if not ffmpeg_path:
            print("\n✗ ERROR: FFmpeg not found!")
            print("Please ensure ffmpeg.exe is in the same folder as this application")
            print("or install FFmpeg on your system.")
            input("\nPress Enter to exit...")
            return

        print(f"✓ FFmpeg found: {ffmpeg_path}")

        # Step 3: Get folders
        folder_path, output_folder = get_user_folders()

        # Step 4: Get preferences
        print("\n" + "=" * 50)
        print("Processing Options")
        print("=" * 50)

        keep_audio_files = yes_or_no_prompt(
            "Do you want to keep the extracted audio files after transcription?",
            default_yes=False
        )

        combine_files = yes_or_no_prompt(
            "Do you want to automatically combine transcripts by language?",
            default_yes=True
        )

        print(f"✓ Audio files will be {'kept' if keep_audio_files else 'deleted'} after processing.")
        print(f"✓ Transcripts will {'be combined' if combine_files else 'remain separate'} by language.")

        # Step 5: Get video files and confirm
        video_files = get_video_files(folder_path)

        if not video_files:
            print("\n✗ No video files found in the specified folder!")
            input("Press Enter to exit...")
            return

        print(f"\n" + "=" * 50)
        print("Files to Process")
        print("=" * 50)
        for i, video in enumerate(video_files, 1):
            print(f"{i:2d}. {os.path.basename(video)}")

        if not yes_or_no_prompt(f"\nProceed with transcribing {len(video_files)} video(s)?", default_yes=True):
            print("Processing cancelled by user.")
            return

        # Step 6: Process videos
        start_time = time.time()
        successful = 0
        failed = 0
        language_stats = {}

        for i, video_path in enumerate(video_files, 1):
            print(f"\n[{i}/{len(video_files)}] Processing video...")

            success, detected_language = transcribe_single_video(
                video_path, output_folder, keep_audio_files, ffmpeg_path
            )

            if success:
                successful += 1
                language_stats[detected_language] = language_stats.get(detected_language, 0) + 1
            else:
                failed += 1

        # Step 7: Combine transcripts if requested
        if combine_files and successful > 0:
            combined_en, combined_de = combine_transcripts(output_folder, output_folder)

        # Step 8: Final summary
        end_time = time.time()
        total_time = end_time - start_time

        print(f"\n{'=' * 60}")
        print("BATCH PROCESSING COMPLETE")
        print(f"{'=' * 60}")
        print(f"Total videos processed: {len(video_files)}")
        print(f"Successful: {successful}")
        print(f"Failed: {failed}")
        print(f"Total execution time: {total_time:.2f} seconds ({total_time / 60:.2f} minutes)")
        if len(video_files) > 0:
            print(f"Average time per video: {total_time / len(video_files):.2f} seconds")

        # Language detection statistics
        if language_stats:
            print(f"\nLanguage Detection Summary:")
            for lang, count in language_stats.items():
                lang_name = {"de": "German", "en": "English"}.get(lang, lang.upper())
                print(f"  {lang_name}: {count} video(s)")

        if combine_files and successful > 0:
            print(f"\nCombined Files Created:")
            if combined_en:
                print(f"  English: Combined_English_Transcripts.txt")
            if combined_de:
                print(f"  German: Combined_German_Transcripts.txt")

        print(f"\nOutput folder: {output_folder}")
        print(f"Audio files: {'Kept' if keep_audio_files else 'Deleted'}")

    except KeyboardInterrupt:
        print("\n\nOperation cancelled by user.")
    except Exception as e:
        print(f"\n✗ Unexpected error: {e}")
    finally:
        input("\nPress Enter to exit...")


if __name__ == "__main__":
    main()
